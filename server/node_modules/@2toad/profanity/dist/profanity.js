"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.profanity = exports.Profanity = void 0;
const profanity_options_1 = require("./profanity-options");
const models_1 = require("./models");
const utils_1 = require("./utils");
const data_1 = require("./data");
class Profanity {
    constructor(options) {
        this.options = options ? { ...new profanity_options_1.ProfanityOptions(), ...options } : new profanity_options_1.ProfanityOptions();
        this.whitelist = new models_1.List(() => this.clearRegexes());
        this.blacklist = new models_1.List(() => this.clearRegexes());
        this.removed = new models_1.List(() => this.clearRegexes());
        this.regexes = new Map();
    }
    exists(text, languages) {
        if (typeof text !== "string") {
            return false;
        }
        const regex = this.getRegex(this.resolveLanguages(languages));
        regex.lastIndex = 0;
        const lowercaseText = text.toLowerCase();
        let match;
        do {
            match = regex.exec(lowercaseText);
            if (match !== null) {
                const matchStart = match.index;
                const matchEnd = matchStart + match[0].length;
                // Check if the matched word is part of a whitelisted word
                let isWhitelisted = false;
                this.whitelist.words.forEach((whitelistedWord) => {
                    const whitelistedIndex = lowercaseText.indexOf(whitelistedWord, Math.max(0, matchStart - whitelistedWord.length + 1));
                    if (whitelistedIndex !== -1) {
                        const whitelistedEnd = whitelistedIndex + whitelistedWord.length;
                        if (this.options.wholeWord) {
                            // For whole word matching, ensure the whitelisted word exactly matches the profane word
                            // and is not part of a hyphenated or underscore-separated word
                            if (matchStart === whitelistedIndex &&
                                matchEnd === whitelistedEnd &&
                                (matchStart === 0 || !/[\w-_]/.test(lowercaseText[matchStart - 1])) &&
                                // eslint-disable-next-line security/detect-object-injection
                                (matchEnd === lowercaseText.length || !/[\w-_]/.test(lowercaseText[matchEnd]))) {
                                isWhitelisted = true;
                            }
                        }
                        else {
                            // For partial matching, check if the profane word is contained within the whitelisted word
                            if ((matchStart >= whitelistedIndex && matchStart < whitelistedEnd) || (matchEnd > whitelistedIndex && matchEnd <= whitelistedEnd)) {
                                isWhitelisted = true;
                            }
                        }
                    }
                });
                if (!isWhitelisted) {
                    return true;
                }
            }
        } while (match !== null);
        return false;
    }
    censor(text, censorType = models_1.CensorType.Word, languages) {
        if (typeof text !== "string") {
            return text;
        }
        const regex = this.getRegex(this.resolveLanguages(languages));
        regex.lastIndex = 0;
        const lowercaseText = text.toLowerCase();
        switch (censorType) {
            case models_1.CensorType.Word:
                return text.replace(regex, (match) => {
                    const underscore = match.includes("_") ? "_" : "";
                    return this.options.grawlix + underscore;
                });
            case models_1.CensorType.FirstChar: {
                return this.replaceProfanity(text, lowercaseText, (word) => this.options.grawlixChar + word.slice(1), regex);
            }
            case models_1.CensorType.FirstVowel:
            case models_1.CensorType.AllVowels: {
                const vowelRegex = new RegExp("[aeiou]", censorType === models_1.CensorType.FirstVowel ? "i" : "ig");
                return this.replaceProfanity(text, lowercaseText, (word) => word.replace(vowelRegex, this.options.grawlixChar), regex);
            }
            default:
                throw new Error(`Invalid replacement type: "${censorType}"`);
        }
    }
    replaceProfanity(text, lowercaseText, replacer, regex) {
        let result = text;
        let offset = 0;
        let match;
        do {
            match = regex.exec(lowercaseText);
            if (match !== null) {
                const matchStart = match.index;
                const matchEnd = matchStart + match[0].length;
                const originalWord = text.slice(matchStart + offset, matchEnd + offset);
                const censoredWord = replacer(originalWord);
                result = result.slice(0, matchStart + offset) + censoredWord + result.slice(matchEnd + offset);
                offset += censoredWord.length - originalWord.length;
            }
        } while (match !== null);
        return result;
    }
    addWords(words) {
        const removedWords = [];
        const blacklistWords = [];
        words.forEach((word) => {
            const lowerCaseWord = word.toLowerCase();
            if (this.removed.words.has(lowerCaseWord)) {
                removedWords.push(lowerCaseWord);
            }
            else {
                blacklistWords.push(lowerCaseWord);
            }
        });
        if (removedWords.length) {
            this.removed.removeWords(removedWords);
        }
        if (blacklistWords.length) {
            this.blacklist.addWords(blacklistWords);
        }
    }
    removeWords(words) {
        const blacklistedWords = [];
        const removeWords = [];
        words.forEach((word) => {
            const lowerCaseWord = word.toLowerCase();
            if (this.blacklist.words.has(lowerCaseWord)) {
                blacklistedWords.push(lowerCaseWord);
            }
            else {
                removeWords.push(lowerCaseWord);
            }
        });
        if (blacklistedWords.length) {
            this.blacklist.removeWords(blacklistedWords);
        }
        if (removeWords.length) {
            this.removed.addWords(removeWords);
        }
    }
    /**
     * Determines the list of languages to use, either from the provided list or falling back to default languages.
     * @param languages - An optional list of languages to use.
     * @returns The list of languages to be used.
     */
    resolveLanguages(languages) {
        return (languages === null || languages === void 0 ? void 0 : languages.length) ? languages : this.options.languages;
    }
    /**
     * Retrieves or constructs a regular expression for detecting profanity in the specified languages.
     * This method first checks if a regex for the given combination of languages already exists in the cache.
     *
     * @param languages - An array of languages to include in the regex.
     * @throws {Error} If no languages are provided.
     * @returns A RegExp object for detecting profanity in the specified languages.
     */
    getRegex(languages) {
        if (!languages.length) {
            throw new Error("At least one language must be provided");
        }
        const uniqueLanguages = [...new Set(languages.map((language) => language.trim().toLowerCase()))];
        const regexKey = uniqueLanguages.sort().join(",");
        if (this.regexes.has(regexKey)) {
            return this.regexes.get(regexKey);
        }
        const allWords = uniqueLanguages.flatMap((language) => {
            const words = data_1.profaneWords.get(language);
            if (!words) {
                throw new Error(`Invalid language: "${language}"`);
            }
            return words.filter((word) => !this.removed.words.has(word));
        });
        const regex = this.buildRegex(allWords);
        this.regexes.set(regexKey, regex);
        return regex;
    }
    /**
     * Constructs a regular expression for detecting profane words.
     *
     * @param words - An array of profane words to be included in the regex.
     * @returns A RegExp that matches any of the profane or blacklisted words.
     */
    buildRegex(words) {
        const allProfaneWords = [...words, ...this.blacklist.words];
        const escapedProfaneWords = allProfaneWords.map(utils_1.escapeRegExp);
        const profanityPattern = `${this.options.wholeWord ? "(?:\\b|_)" : ""}(${escapedProfaneWords.join("|")})${this.options.wholeWord ? "(?:\\b|_)" : ""}`;
        // eslint-disable-next-line security/detect-non-literal-regexp
        return new RegExp(profanityPattern, "gi");
    }
    /**
     * Clear the cached regexes.
     */
    clearRegexes() {
        this.regexes.clear();
    }
}
exports.Profanity = Profanity;
exports.profanity = new Profanity();
//# sourceMappingURL=profanity.js.map